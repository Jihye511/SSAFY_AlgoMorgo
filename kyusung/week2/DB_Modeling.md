# 데이터베이스 모델링

모델링 : 실제 현상을 간단한 형태로 기술하거나 예측

DB 모델링 : 현세의 데이터를 분석 → DB 구조를 설계하기

### 필요성

- 데이터 무결성 유지
- 중복 최소화
- 효율적인 검색 : (index 활용)
- 유지보수 용이 : 데이터 구조 변경 시 영향 최소화

### 과정

1. 요구사항 수집 및 분석
2. 개념적 데이터 모델링
    - 추상화
    - 핵심 entity와 그 사이의 관계 →  개념 ERD 작성
3. 논리적 데이터 모델링
    - 정규화 작업
    - 논리 ERD 작성
4. 물리적 데이터 모델링
    - 역정규화 (데이터의 중복을 허용)
    - 인덱스, 파티셔닝, 스토리지등 고려 성능 최적화
5. DB 구축

- 설계 : 개-논-물

# 요구사항 수집 및 분석

### 수집

문서, 시스템, 워크샵 및 인터뷰, 설문조사, 프로토타이핑을 통해 수집

### 분석

DB 목적 파악 → 저장, 관리할 데이터 구조, 관계, 제약 조건등 정의

비즈니스 규칙 파악

산출물 : 요구사항 명세서 , 도메인 용어사전

# 개념적 데이터 모델링 : 추상화

엔터티, 속성, 관계를 정의

→ 개념 ERD 산출

![image](https://github.com/user-attachments/assets/6742acbb-d102-42d2-803c-dc41e1b63b34)

사각형 : 개체

마름모 : 관계

타원 : 속성

## 개체 (Entity)

: 시스템에서 저장, 관리할 물리적, 개념적 대상

- 영속적이고 식별 가능한 데이터 요소
- 둘 이상의 속성을 가진 집합을 표현

### 개체 유형

- 유/무형에 따라
    - 유형 엔티티 : 물리적 형태가 존재 ( 사원 )
    - 개념 엔티티 : 물리적 형태는 없지만 관리할 개념적 정보 ( 부서 )
    - 사건 엔티티 : 업무를 수행함에 따라 발생 (태초부터 존재 X)  ( 주문, 청구)
- 발생 시점에 따라
    - 기본 엔티티 : 원래 존재하는 정보, 타 엔티티에 의존 X 독립적 생성 (사원)
    - 중심 엔티티 : 기본 엔티티로부터 발생, 업무에서 중심적 역할 (주문)
    - 행위 엔티티 : 중심 엔티티로부터 보다 더 세부적 정보를 위해 파생 (주문 목록)

### 개체 식별

1. 명사로 된 단어 (개체와 속성의 후보로 함축)
2. 비즈니스 분석 범위 내 명사
3. 찾은 명사 중 같은 의미로 사용되면서 다르게 표현되는 단어 배제
4. 여러개의 속성으로 구성되는지 확인
5. 집합인지 확인

### 검증

CRUD Matrix 상관분석

: 추출한 엔티티와 모델링에서 도출한 단위 프로세스를 이용해 작업

![image](https://github.com/user-attachments/assets/7a958ef0-3e30-4a17-b73a-80923eda8bff)

- 체크한다고 엔티티가 아닌 것은 아님.

## 속성

하나의 엔티티에 종속되는 명사적 단어

엔티티를 표현하는 특성, 상태

### 유형

- 기본 속성 : 업무 분석에서 유래된 본 속성
- 설계 속성 : 설계 과정에서 발생하는 인위적으로 추가하거나 변형한 속성 (isDeleted 같은 flag 속성)
- 파생 속성 : 다른 속성에서 파생되어 계산 (주민번호 → 생일, 성별 유추 가능)

### 키

키 속성 추출 : 하나의 엔티티를 구성하는 속성 중 엔티티를 유일하게 식별하는 하나 이상의 속성 조합

모든 엔티티는 단 하나의 식별자를 가짐

### 키 유형

- 슈퍼 키 : 레코들을 유익하게 식별할 모든 속성들의 가능한 조합의 집합
- 후보 키 : 슈퍼 키 중 최소성을 만족하는 키
- 기본 키 : 후보 키 중 가장 적합한 하나를 선택한 키
- 대체 키 : 후보 키 중 기본키가 아닌 것 ( UNIQUE 제약 조건으로 설계 가능 )
- 인조 키 : 슈퍼 키가 없는 경우 인공적으로 만든 키 (인덱스?)
    - 슈퍼 키가 존재하지만 너무 많은 속성의 집합인 경우 인위적 생성 가능

## 관계

- 두 엔티티 간의 업무적 상관관계
- 추출 : 동사적 단어 추출, 중복 속성이 있는지 체크
- 검증 : Relationship Matrix

### 관계 차수 (카디널리티)

관계의 유형 

- 1 : 1 관계
- 1 : N 관계 : 가장 많이 보임
- N : N 관계 : 관계(연결) 엔티티로 해결 필요 ⇒ 해봤따.

## 개념 ERD

- 피터 첸 표기법

![image](https://github.com/user-attachments/assets/c8127924-541a-4fde-b41a-9c16b3db98f3)

![image](https://github.com/user-attachments/assets/f51635b6-0f2b-4203-9234-59581fbeec24)

![image](https://github.com/user-attachments/assets/54e96bfc-64ff-450e-8517-0e9f06d6a992)

# 논리적 데이터 모델링

: 개념적 데이터 모델링의 산출물 (ER모델)을 구체화된 업무 중심의 관계형 데이터 모델로 만든다.

- 개념 모델을 구체화해 데이터의 논리구조 정의

| **E-R 모델** | **관계형 데이터 모델** |
| --- | --- |
| 엔티티 | 릴레이션(Relation) |
| 속성 | 속성 |
| 후보 키 | 기본 키, 대체 키 |
| 관계 | - 외래 키 (1:1관계, 1:N관계)- 릴레이션(N:M관계) → N:M 관계 해소 |
- 정규화
- 산출물 : 논리 ERD (릴레이션 스키마)

### 기본 키 정의

- 후보 키 중 가장 적합한 하나 선정
- 업무 활용도 ↑, 길이 너무 길지않도록

### N:M 관계 해소

- 데이터 중복 반드시 발생
- 릴레이션으로 도출해 1 : N으로
- 기본키 : 두 릴레이션의 기본키를 조합해 복합키 형태로 구성 or 인공키 생성

### 외래 키 정의

- 관계를 외래키로 표현
- 자식 릴레이션에 외래키 추가

## 정규화

: 중복을 최소화하고 무결성 유지를 위해 새로운 엔티티를 도출

- 속성간에 존재하는 함수성 종속성을기반으로 유연한 구조로 정제
- 총 5단계 중 보통 3단계
- 장 : 저장공간 절약 및 성능 개선, 데이터 무결성, 삽입/수정/삭제 이상 방지
- 단 : 물리적 접근이 복잡 → 많은 조인 必, 길이가 짧은 데이터가 생김

![image](https://github.com/user-attachments/assets/bf124ed7-de5e-4b16-b0ed-462e86595eff)

- 3 → BCNF : 모든 결정자는 후보키여야 한다.

### 제 1 정규화

: 모든 속성이 원자값을 가지고 있어야한다. → 컬럼에 원자값 저장 ❌

- 대상 : 다치 속성을 갖는 릴레이션
- 과정
    1. 반복되는 속성을 새로운 릴레이션으로 분리
    2. 새로운 릴레이션의 기본키를 정의
    3. 두 릴레이션 간의 관계 부여 (외래키 정의)

### 제 2 정규화

: 1정규화 만족하면서, 부분적 함수 종속을 제거

- 대상 : 기본 키가 복합키 형태이며, 기본 키의 일부에만 종속성을 갖는 속성을 지닌 릴레이션
- 과정
    1. 기본 키의 일부 속성과 기본 키 전체 속성이 아닌 이 속성에만 종속성을 갖는 속성을 새로운 릴레이션으로 분리
    2. 새로운 릴레이션의 기본키를 정의
    3. 두 릴레이션 간의 관계 부여 (외래키 정의)

### 제 3 정규화

: 2정규화를 만족하면서, 이행적 함수 종속을 제거

- 대상 : 기본키가 아닌  속성이 다른 속성의 결정자 역할을 하는 릴레이션
- 과정
    1. 기본 키가 아닌 다른 속성에 의해 종속성을 갖는 속성과 그 결정자 속성을 새로운 릴레이션으로 분리
    2. 새로운 릴레이션의 기본키를 정의
    3. 두 릴레이션 간의 관계 부여 (외래키 정의)

> **이행적 함수 종속**
A→B, B→C일 때, A→C 를 만족하면 이행적 함수 종속
> 

# 물리적 데이터 모델링

: 논리 모델링 결과를 실 DB에서 구현 가능한 형태로 변환

| **관계형 데이터 모델** | **DBMS** |
| --- | --- |
| 릴레이션(Relation) | 테이블(Table) |
| 속성 | 컬럼(Column) |
| 기본 키, 대체 키, 외래키 | 제약조건(PK, UNIQUE, FK) |
- DBMS의 특성을 고려해 타입, 크기, 인덱스, 파티셔닝, 저장구조 등 결정
- 역정규화 고려
- 산출물 : 물리 ERD

### 역정규화

: 정규화된 데이터를 성능 향상을 위해 일부 중복 허용 or 다시 합치는 과정

- 테이블 병합, 중복 데이터 허용
- 조회 성능은 개선, 데이터 일관성 관리는 어려워질 수도
- 결과적으로 테이블 개수 ↓
- 컬럼 역정규화
    - 조인이 잦은 컬럼 추가
    - 조인 패스가 깊은 컬럼 추가
    - 파생 컬럼 추가
- 테이블 역정규화
    - 집계 테이블 추가
    - 조인이 잦은 테이블과 통합

### 테이블 분할

- 수평적 분할

![image](https://github.com/user-attachments/assets/18e87776-1a77-463f-9ed7-f8c96c72dc72)

- 수직적 분할

![image](https://github.com/user-attachments/assets/fc33c9aa-3f50-4af0-aa27-b81ab8e3fc72)
