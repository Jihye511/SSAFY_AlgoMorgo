# 스프링 빈

- 스프링 프레임워크에 의해 생성되고 관리되는 자바객체
- 스프링은 빈의 생성, 의존 관계 설정, 객체 관리 등 빈의 라이프 사이클을 관리
    - 스프링을 빈의 컨테이너라고 함

- 의존 관계 : 객체 has-a → 어떤 객체가 비즈니스로직 처리를 위해 다른 객체에 의존하는 관계
- 의존 관계 관리를 위헤 DI 개념을 사용하며 이 과정에서 제어의 역전이 발생
    - 스프링을 IOC (Inversion Of Control) 컨테이너라고 불림

## 스프링

객체를 빈이라는 개념으로 관리 → Spring은 빈의 Container → 그냥 POJO로 만들면 됨

재사용 하려면 싱글톤으로 해야하지만 클래스의 형식을 강제함

근데 POJO는 너가 하고싶은데로 하면 되 → 스프링이 해줄게

스프링은 설정에 따라 의존성을 가지고 있는 빈을 주입 → DI

### DI

- 객체의 의존성 즉 멤버 변수를 외부에서 주입하는 것
- 멤버 변수 설정 방법
    - 직접 field에 할당
    - 생성자를 활용
    - setter 메서드 이용

Spring Bean 관리 과정

1. POJO로 빈 구성
2. 빈 구성 정보 (메타정보 → 빈 생성 방법 및 관계 설정 정보) 스프링 컨테이너에게 전달
3. 빈 생성 및 주입 (런타임에 스프링은 메타 정보를 보고 빈 객체 생성 후 주입 → 싱글톤 형태로 관리)
4. 빈 요청
5. 빈 반환
6. 빈 사용

## 묵시적 DI

스프링은 타입 기반으로 빈을 관리한다

근데 타입에서 충돌할때 이름 기반으로 한다

component로 이름을 하지만

Pascal case는 첫글자 소문자로 한 camel case, 그렇지 않은 경우 클래스 이름 그대로 사용

## 1. 카멜식 (Camel case)

- 낙타 모양에서 따온 방법으로 첫글자는 소문자로 시작, 두번쨰 단어부터는 대문자로 표현하는 방식으로 많이 사용합니다.

원문 : USER LOGIN LOG

카멜식 : userLoginLog

## 2. 파스칼식 (Pascal case)

- 카멜식이랑 비슷하지만 차이점은 첫단어를 대문자로 시작합니다.

원문 : USER LOGIN LOG

파스칼식 : UserLoginLog

pascal case란 : 

### 빈 주입 : Autowiresd

타입 기반으로 빈 자동 주입 - 해당 빈은 반드시 하나만 존재

→ 충돌시 이름 기반 조건 추가 : @Qualifier

생성자와 메서드에서 사용 시 대상 파라미터는 모두 Spring Bean 또는 @Value에 의한 scalar 값

한 클래스에 @Autowired에 적용된 생성자는 최대 하나만 가능, 메서드는 여러번 사용 가능

생성자가 1개인 경우 당연히 그 생성자가 호출 되므로 @Autowired 생략 가능

### @ComponentScan

빈이 될 수 있다지만 실제로 빈 안만듬

대상 빈을 scan 해야 빈으로 등록됨

@Configuration이 선언된 클래스에서만 에서만 사용함

basePackages → component를 찾아볼 package 등록 → 하위 패키지 모두 scan

### 주입방식 DI

- 생성자 → 가장 권장됨
    - 빈의 모든 의존성이 반드시 필요하다는 것을 명시적으로 보여줌
    - 빈의 순환 의존성 문제를 빈 생성 시점에 즉시 발견 가능
        - 다른 방식은 빈 생성 후 주입과정에서 발견
    - 많은 경우 field를 blank final(final로 선언하고 값 할당 X)로 선언하고 생성자 주입을 사용하는데 lombok의 @RequiredArgsConstructor 활용
    - blank final은 생성자에서만 할당 가능
- saetter 주입
    - 선택적인 의존성을 가진 빈의 주입에 적합

- field 주입 → 비추
    - 코드 간결 but 테스트 시 Mock 객체 주입 어렵, 빈 불변성 보장 X
    - 단위 테스트처럼 특별한 목적을 위해 작성된 경우에만 사용 권장

![image.png](attachment:edb265cd-8cd5-4961-8f8d-caa6946f6111:image.png)
