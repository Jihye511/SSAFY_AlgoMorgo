Framework : ( Vue.js) : Single File Component
# Component

재사용 가능한 코드 블록

### 특징

- UI를 독립적이고 재사용 가능한 일부분으로 분할하고 각 부분을 개별적으로 다룰 수 있음
    - 자연스럽게 애플리케이션은 중첩된 Component의 트리 형태로 구성됨

# Single-File Components (SFC)

- 컴포넌트의 템플릿, 로직 및ㅇ 스타일을 하나의 파일로 묶어낸 특수한 파일 형식 (*.vue 파일)

### 문법

- 각 *.vue 파일은 세 가지 유형의 최상위 언어 블록 <template>, <script>, <style>으로 구성됨
- 언어 블록의 작성 순서는 상관 없으나 일반적으로 template → script → style 순서로 작성

## <template>

- 각 *.vue 파일은 최상위 <template> 블록을 하나만 포함할 수 있음

### 모든 컴포넌트에는 최상단 HTML 요소가 작성되는 것이 권장

- 가독성, 스타일링, 명확한 컴포넌트 구조를 위해 각 컴포넌트에는 최상단 HTML 요소를 작성해야 함 (Single Root Element)

## <script setup>

- 각 *.vue 파일은 <script setup> 블록을 하나만 포함할 수 있음 (일반 <script> 제외
- 컴포넌트의 setup() 함수로 사용되며 컴포넌트의 각 인스턴스에 대해 실행

## <style scoped>

- *.vue 파일에는 여러 <style> 태그가 포함될 수 있음
- scoped가 지정되면 CSS는 현재 컴포넌트에만 적용

### 관심사항의 분리가 파일 유형의 분리와 동일한 것이 아니다

- 프론트-엔드 앱의 사용 목적이 점점 더 복잡해짐에 따라, 단순 파일 유형으로만 분리하게 될 경우 프로젝트의 목표를 달성 하는데 도움이 되지 않게 됨

## 스타일 가이드

- 멀티 워드 컴포넌트 이름 사용 (A. 필수)
    - 일반 HTML 요소와의 충돌을 방지하기 위해서 여러 단어를 결합해서 사용
- 싱글 파일 컴포넌트 파일명 대/소문자 (B. 강력 추천)
    - 싱글 파일 컴포넌트의 파일 명은 항상 파스칼 케이스나 케밥 케이스로 한다
- 기본 컴포넌트 이름 (B. 강력 추천)
    - 앱별 스타일과 규칙을 적용하는 기본 컴포넌트는 모두 Base, App, V와 같은 특정 접두사로 시작한다
- 긴밀하게 결합된 컴포넌트 이름 (B. 강력 추천)
    - 부모 컴포넌트와 긴밀하게 결합된 자식 컴포넌트는 부모 컴포넌트 이름을 접두사로 포함한다
- 컴포넌트 이름 내 단어 순서 (B. 강력 추천)
    - 컴포넌트의 이름은 가장 일반적인 단어에서 시작하고 설명적인 단어로 끝난다
- 전체 단어를 사용한 컴포넌트 이름 (B. 강력 추천)
    - 컴포넌트 이름은 약어보다 완전한 단어를 사용하는 것이 좋다
- 컴포넌트 범위의 스타일 사용하기 (A. 필수)
    - 일반적으로 scopped를 이용. 다만 라이브러리는 클래스 기반 전략 활용

### SFC의 CSS 기능 - scoped

- scoped를 사용하면 부모 컴포넌트의 스타일이 자식 컴포넌트로 유출되지 않음
- 단, 자식 컴포넌트의 최상위 요소 (root element)는 부모와 자식의 CSS 모두의 영향을 받음
- 부모가 레이아웃 목적으로 자식 컴포넌트 최상위 요소의 스타일을 지정할 수 있도록 의도적으로 설계된 것
- scoped 주의
    - 부모 컴포넌트에 적용된 스타일은 scoped가 작성 되어 있지만, 자식의 최상위 요소는 부모와 본인의 CSS  모두의 영향을 받기 때문에 부모의 스타일이 적용됨

# Props (property)

- 부모는 자식에게 데이터를 전달 (Pass Props)하며, 자식은 자신에게 일어난 일을 부모에게 알림 (Emit event)
- 부모 컴포넌트로부터 자식 컴포넌트로 데이터를 전달하는데 사용되는 속성

## 특징

- 부모 속성이 업데이트되면 자식으로 전달 되지만 그 반대는 안됨
- 즉, 자식 컴포넌트 내부에서 props를 변경하려고 시도해서는 안되며 불가능
- 또한 부모 컴포넌트가 업데이트될 때마다 이를 사용하는 자식 컴포넌트의 모든 props가 최신 값으로 업데이트 됨
- 부모 컴포넌트에서만 변경하고 이를 내려 받는 자식 컴포넌트는 자연스럽게 갱신

### One-Way Data Flow

- 모든 props는 자식 속성과 부모 속성 사이에 하향식 단방향 바인딩을 형성

단방향인 이유

- 하위 컴포넌트가 실수로 상위 컴포넌트의 상태를 변경하여 앱에서의 데이터 흐름을 이해하기 어렵게 만드는 것을 방지하기 위함
- 데이터 흐름의 일관성 및 단순화

### Props 선언 방식

1. 문자열 배열을 사용한 선언 → defineProps()
2. 객체를 사용한 선언
    - 객체 선언 문법 권장하는 이유
        - props에 타입에 지정하는 것은 컴포넌트를 가독성이 좋게 문서화하는데 도움이 되며, 다른 개발자가 잘못된 유형을 전달할 때에 브라우저 콘솔에 경고를 출력하돍 함
        - 추가로 props에 대한 유효성 검사로써 활용 가능

- 상세한 Prop 정의 사용 (A- 필수)
    - prop 정의는 최소한 타입을 명시해야 한다

### prop 데이터 사용

- props를 객체로 반환하므로 필요한 경우 JS에서 접근 가능
- 템플릿에서 반응형 변수와 같은 방식으로 활용
- prop 출력 결과 확인

- prop 이름 표기법 (B- 강력  추천)
    - prop 이름은 선언 시 camelCase를 사용한다. SFC에서 사용 시는 camelCase 또는 kebabCase를 사용하는데 일관성을 유지하자.

### Dynamic props

- v-bind를 사용하여 동적으로 할당된 props를 사용할 수 있음

# Component Event

- 부모는 자식에게 데이터를 전달(Pass Props)하며, 자식은 자신에게 일어난 일을 부모에게 알림(Emit event)
- 부모가 props 데이터를 변경하도록 소리쳐야 한다

### $emit()

- 자식 컴포넌트가 이벤트를 발생시켜 부모 컴포넌트로 데이터를 전달하는 역할의 메서드
    - ‘$’ 표기는 Vue 인스턴스의 내부 변수들을 가리킴
    - 라이프 사이클 훅, 인스턴스 메소드 등 내부 특정 속성에 접근할 때 사용

### 이벤트 발신 및 수신

- $emit을 사용하여 템플릿 표현식에서 직접 사용자 정의 이벤트를 발신
- 그러면 부모는 v-on 을 사용하여 수신할 수 있음

## emit 이벤트 선언

- defineEmits()를 사용하여 명시적으로 발신할 이벤트를 선언할 수 있음
- defineEmits()는 $emit 대신 사용할 수 있는 동등한 함수를 변환
    - script에서는 $emit 메서드를 접근할 수 없기 때문

### 이벤트 인자

- 이벤트 발신 시 추가 인자를 전달하여 값을 제공할 수 있음

### Event Name Casing

- 선언 및 발신시 → camelCase
- 부모 컴포넌트에서 수신 시 → kebab-case
