Stateless : 상태를 기억하지 않음

이유 :

단순성 : 각 요청이 독립적으로 처릭 되기 때문에 이전 요청과 연결할 필요가 없고 서버의 구성이 단순해지며 속도가 빠름

확장성 : 여러 서버 간 공유해야 할 상태가 없기 때문에 여러 서버에 요청을 분산시킬 수 있어 부하 분산 및 시스템 확장이 용이

신뢰성 : 요청들이 독립적이기 때문에 한 요청의 실패가 다른 요청에 영향을 미치지 않음으로 시스템 신뢰도 향상

자원절약 : 서버에서 상태를 저장하지 않기 때문에 그만큼 서버의 메모리, 저장 공간 ㅈ벌약

# cookie

웹 서버에서 정보를 생성해서 클라이언트에 보관하는 데이터

## 주요 property

- name을 제외한 property는 setter/getter로 접근 가능
- name : 쿠키를 만들 때 전달하는 쿠키의 이름으로 각각의 쿠키를 구별하는 유일한 값
    - 동일한 이름의 쿠키는 기존 쿠키를 덮어씀
    - 알파벳, 숫자, 하이픈, 언더스코어, 틸트, 접으로 구성되며, 공백 등 나머지는 URLEncoder를 통해 인코딩 필요
- value : 쿠키의 값으로 쿠키 생성 시 전달하거나 setValue() 메서드를 통해 설정 가능
    - 작성 규칙은 name과 동일, 한글 사용은 가능
- domain : 지정 도메인과 그 하위 도메인에서 쿠키를 공유하고자 할 때 사용
    - 기본적으로 설정된 도메인과 그 하위 도메인만 접근 가능
    - 하지만 other.example.com 등은 접근 불가
- path : 쿠키가 유효한 경로
    - path가 설정된 하위 경로에서만 쿠키 전송
    - 경로 미 설정 시 : context root 설정
    - / 즉 container root로 지정하면 동일 도메인의 다른 어플가지 접근
    - 보안이슈 발생할 수 있음
- maxAge : 큐키의 유효기간
    - 양수 : 초 단위로 해당 시간까지 쿠키 존재, 시간 지나면 자동 폐기
    - 음수 / 미지정 : 세션 쿠키로 브라우저 종료 등으로 세션 종료 시 폐기
    - 0 : 브라우저에 도착하는 즉시 폐기
- secure : HTTPS에서만 전송 허용
- httpOnly : JS에서 접근 불가 설정

쿠키는 요청을 통해 서버로 전송됨, forwrad된 page에서 즉시 확인 가능?

- JSP 에서 쿠키 확인이 되나?

# Session

- 서버에 클라이언트의 상태 값을 저장
- 하나의 브라우저 당 하나의 세션 성립
- 쿠키는 브라우저를 닫아도 유지될 수 있으나 세션은 브라우저를 닫으면 종료
- 세션이 동작하기 위해서는 JSESSIONID라는 이름의 쿠키 필요
    - JSESSIONID는 서버의 세션 공간에 들거가기 위한 키

removeAttribute : session의 여러개 속성 중 name에 해당하는 속성 하나만 제거

invalidate : 그 세션을 파괴

### HttpSession 유효시간

- WAS의 web.xml에 container 차원의 session-timeout 설정
    - 설정 시간은 분 단위
- 애플리케이션 별 web.xml에서 contet 단위 재정의 가능
- HttpSession#setMaxInactiveInterval(int sec)을 통해 프로그래밍 적으로 재정의 가능
    - 초 단위로 세션의 유효 기간 설정

# 강사님 정리

기본쿠키 : JSessionID

한번도 요청 안하면 쿠키가 없다

근데 한번이라도 웹서버 거쳤다면 기본쿠키가 만들어진다 (자동으로)

서비스에서 쿠키 호출하는 방법

request에서 getcookie

브라우저는 쿠키를 자동으로 집어넣음

쿠키는 서버에서 만든다

브라우저는 쿠키영역에 저장한다

쿠키영역 : 실제로는 파일이다

쿠키를 삭제하는건 서버에서

- Maxage를 0으로
- remove
- invalidate

브라우저에서 쿠키 삭제는 JS에서
