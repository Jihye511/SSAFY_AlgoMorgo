## DB 모델링의 필요성

- 데이터 무결성 유지
- 중복 최소화
- 효율적인 데이터 검색
- 유지보수 용이성

## DB 모델링 과정

1. 요구사항 수집 및 분석
- 사용자 요구 사항 수집 및 명세화

1. 개념적 데이터 모델링
- 핵심 Entity와 관계 도출
- 개념 ERD 작성

1. 논리적 데이터 모델링
- 구체화된 업무 중심의 데이터 모델 작성
- 정규화 적용, 중복 최소화
- 논리 ERD 작성

1. 물리적 데이터 모델링
- 역정규화
- 인덱스, 파티셔닝, 스토리지 등 고려하여 성능 최적화
    - 파티셔닝 : 레코드를 분류에 따라 모이게 만들기
1. 데이터 베이스 구축

## 요구사항 수집

문서, 시스템, 워크샵 및 인터뷰, 설문조사, 프로토타이핑

## 요구사항 분석

체계적 정리 및 분석하여 개발할 DB 용도 파악

어떤걸 저장하고 관리해야 할 데이터 뽑아냄

비즈니스 규칙 도출 및 분석

ex) 회원제 시스템 :

회원 가입 후 서비스 이용 가능 → 로그인 서비스 필요

- 로그인 서비스
    - 로그인 실패 시 계속 로그인 시도 가능하게?
    - 5번까지만 시도 가능 → 실패하면 자동 비번 초기화

## 개념적 데이터 모델링

데이터 측면에 포커스를 맞춘 모델링

업무 프로세스, 요구사항 분석, 다른 사람들이 이해하기 쉬운 형태로 표현

언어로 표현한 것은 한눈에 파악이 어렵고 관계 파악도 쉽지 않음

개체 - 관계 모델을 가장 많이 사용

- 개체 (엔티티) 추출
- 속성 추출
- 관계 추출

산출물 : 개념 ERD

### 개체

시스템에서 지속적으로 저장하고 관리해야 하는 물리적, 개념적 대상

영속적이며 식별가능한 데이터 요소를 가짐

- 일시적으로 존재하는 데이터는 엔티티가 아니다

둘 이상의 속석을 표현한 집합

중복X

유/무형 엔티티

- 유형 엔티티 : 물리적 형태 O ( 사원)
- 개념 엔티티 : 관리할 개념적 정보 (부서)
- 사건 엔티티 : 업무 수행 (주문)

발생 시점

- 기본 엔티티 : 의존 X, 독립적 생성 ( 사원)
- 중심 엔티티 : 기본 엔티티로 부터 발생한 중심 역할 ( 주문)
- 행위 엔티티 : 중심 엔티티로 부터 발생한 세부적 정보 (주문 목록)

### 개체 식별

1. 명사로 된 단어 찾기 : 개체와 속성 후보
2. 비즈니스 분석 범위 내의 명사만 찾기
3. 찾은 명사 중 같은 의미로 사용되면서 다르게 표현되는 단어는 버릴 것
4. 여러 개의 속성으로 구성도리 수 있는 지 체크
5. 집합을 표현하는 지 체크

## 속성

하나의 엔티티에 종속되는 명사적 단어

엔티티를 표현하는 특성, 상태 (ex. 회원 번호, 이름,연락처)

유형

- 기본 속성 : 업무 분석에서 도출된 본래의 속성
- 설계 속성 : 설계 과정에서 발생하는 인위적으로 추가하거나 변형한 속성
    - ex. 회원 탈퇴 : 내부적으로 플래그 처리하는 경우가 많음
- 파생 속성 : 다른 속성에서 파생되어 계산된 속성

### 키 속성 추출 → 정규화에서 중요! (키 속성과 함수적 종속이 중요)

엔티를 하나 이상의 속성 조합유일하게 식별하는 

단 하나의 식별자를 가져야함

### 키 유형

- 슈퍼키 : 유일하게 식별할 수 있는 조합 집합
- 후보키 : 슈퍼 키 중 최소성 만족 키 (식별하기 위한 최소환의 속성으로만 구성)
- 기본키 : 후보키 중 가장 적합한 하나선택키 - pk 제약조건
- 대체키 : 후보 키 중 기본키로 선택되지 않는 키 - unique 제약조건 설계 가능
- 인조키 : 슈퍼키가 없는 경우 인공적으로 만든키 - 슈퍼키 존재, but 속성의 집합인 경우 인위적 생성 가능

## 관계

두 엔티티 간의 업무적 상관 관계

동사적 단어 추출

중복되는 속성이 있는 지 체크

### 관계 차수

1 : 1 

1 : N : 가장 많이 보이는 관계

N : M : 관계 엔티티로해결 필요

## 논리 데이터 모델링

- ER모델을 구체화된 업무 중심의 관계형 데이터 모델로 만듦
- 개념 모델을 구체화 하여 논리적 구조

ER모델          관계형 데이터 모델

엔티티   →    릴레이션 (테이블을 의미하는 릴레이션과 다름 함 찾아바)

속성       →    속성

후보키   →    기본 키, 대에 키

관계       →     외래 키(1:1, 1:N), 릴레이션(N:M)

- 정규화
- 산출물 : 논리 ERD : 릴레이션 스키마

기본 키 정의

- 후보 키 중 가장 적합한 하나를 선택한 키

### N:M 관계 해소

- 데이터 중복 발생
- 관계를 릴레이션으로 도출해서 1:N으로
- 두 릴레이션의 기본키를 조합해 복합 키 형태로 구성 or 인공키 생성
- 관계 릴레이션에 관계 관련된 추가 속성 정의 가능
- 기본키가 관계 릴레이션의 외래키로 표현

### 외래 키 정의

관계를 외래 키로 표현

관계 차수에 따른 부모, 자식 릴레이션 확인 후 자식 릴레이션 쪽에 외래키 추가

### 정규화

장점 :

- 데이터 중복 최소화로 저장 공간 절약 및 성능 개선
- 무결성 유지
- 삽입,수정,삭제 이상 방지 가능

단점 :

- 물리적 접근이 복잡해짐 : 많은 조인
- 길이가 짧은 데이터 생김

1정규형 : 원자값이 아닌 도메인 분해 즉 다중속성

2정규형 : 부분적 함수 종속 제거

3정규형 : 이행적 함수 종속 제거

BNF 릴레이션 : 모든 결정자는 후보키여야 한다

# 강사님 정리

관계형 DB : 튜플형태를 표로 저장

엔티티,어트리뷰트,릴레이션 : 개념적

### 모델링

1. 업무분석 : 개념적 모델링 (그 결과물이 개념적 erd)
2. 논리적 모델링 : 

논리와 물리는 표 하나에서 저장해서

개념적 erd 툴은 거의 없다 → 단순한 기호로 표시해서

—> 관계형 DB랑 상관없는거다

—> 현실의 업무 분석을 통한 결과물 도출

1. 물리적 모델링 : 제품에 맞게 변형, 프로젝트에 맞는 형태
2. 업무 프로세스

개념적

기호 : 객체(사각형), 속성(타원), 관계(마름모)

객체 : 업무분석을 통해 상속적으로 저장되어서 관리되야 하는 N개의 인스턴스를 받는 구조

—> 엔티티로 정의한다

—> 주로 명사가 엔티티가 된다

단계 :

엔티티 정하고 릴레이션(관계)를 정하고 어트리뷰트

# 데이터 저장하는 이유 : 나중에 재사용 하기 위해

객체

unique, not null, 엔티티의 속성을 대표할 수 있는지, 짧은거 → 식별자

—> 밑에다가 밑줄을 그어라

속성

기초 : 실제 데이터 구성

추출 : 계산

설계 : 임의로

관계형 DB : 계층형 DB의 장점을 가져옴, 네트웟(망형) DB의 장점을 가져옴

망형 : 관계만 맺음 → 위아래가 없다

계층형 : 위 아래만 있다

관계형 DB는 N:M 구현 X

개념적에서는 되지만 논리적에서는 불가능

논리적

1. 관계형DB 형태로 바꾸기
2. 정규화 단계

중요 이걸 이해하야 조인이 이해

## 기본키

- 후보키 중 선택한 주 키
- 널값 가질 수 X
- 동일한 값이 중복 저장 x

## 포린키

- 관계를 맺는 두 엔티티에서 서로 참조하는 릴레이션의 애트리뷰트로 지정되는 키 값

두개의 테이블을 연결하는거 join

조인할때 어떤 컬럼 쓰니?

부모의 PK를 통해 자식을 접근

> : 최소한 1명 이상있는거 : mandatory
> 

원 : 0명 이상 : optional

1:1은 mandatory와 optional을 잘라야 한다

N:M

이거는 1 : N : `1로 표현하기

릴레이션을 테이블로 정의하고 학생의 pk를 그 릴레이션으로, 과목의 pk를 그 릴레이션으로

여러개의 pk를 가진걸 복합키 : 정규화의 대상

정규화는 필수는 아니다

중복없이 정확한 위치를 시키는 과정

대부분 1,2,3 정규화만 함

1정규화 : 반복 데이터 정리

2정규화 : 복합키 테이블이 대상

3정규화 : 모든컬럼은 pk에 종속적이어야 한다

# 물리

실제로 어떤걸 적용할지 모든걸 정하는걸

- 논리적 데이터베이스 모델링 단계에서 얻어짂 데이터베이스 스키마를
좀더 효율적으로 구현하기 위핚 작업과, DBMS 특성에 맞게 실제
데이터베이스 내의 개체들을 정의하는 단계
    - Column의 domain 설정 (text, integer, real, BLOB, null)

- 데이터 사용량 분석과 업무 프로세스 분석을 통해서 보다 효율적인
데이터베이스가 될 수 있도록 효과적인 인덱스를 정의하고 상황에 따른
역정규화 작업을 수행함.
    - Index, Trigger, 역정규화

## 인덱스 원리

컬럼이 많으면 하나의 데이터를 넣을 때 저장해야하는 데이터가 많다 → 페이지 오버가 일어난다

→ 하나의 데이터가 여러 페이지를 걸쳐 일어남

인덱스는 목차를 만드는 개념이다

자주 사용하지 않은 것은 인덱스로 만들 필요가 없다

같은 데이터가 많은경우 인덱스 스캔보다 테이블 스캔이 빠르다

인덱스 스캔은 싱글 블록 서치

테이블 블록은 멀티 블록 서치

검색해서 나온게 12%가 넘어가면 인덱스가 더 느리다

자주쓰지 않은 조건문같은 경우도 인덱스가 더 느리다

그럼에도 인덱스 쓰면 스캔이 아니면 서치가 일어난다

→ b트리 인덱스

클라스터 인덱스?

실제 이런 트리를 만드는게 아니라

데이터 자체를 정렬해 버린다

( ex. 이름에 클라스터 인덱스 걸면 이름순으로 정렬함)

→ 처음어디부터 ~다음어디까지 한다 하면 처음까지 가고 계속 읽으면 된다

인덱스가 많으면 플랜을 만들기 어렵다

인덱스 말그대로 고속도로 뚫어논거다

플랜을 고속도로에 태워서 감

근데 그 고속도로가 무조건 빠른게 아니다

너무 많은 인덱스는 플랜을 만드는데 옵티마이저에 혼란을 만들 수 있어서 느려질 수 있다

장점 : 서치가 일어날 수 있다는 아주 큰 장점

근데 이거만 쓴다해서 무조건 빨라진다는게 아니다

그러면 어디다 인덱스 쓰냐?

교통량 등 계산해서 인덱스 쓴다

## 역전교환

모든 학생의 평균 점수 → 모든 점수 가져와서 avg 걸기

근데 그 데이터가 천만건 된다 하면 오래걸린다

인덱스 걸어도 한계가 있다

이걸 빠르게 하는 방법?

집계 테이블을 만들어 버림

그리고 일 배치를 돌림

저녁때마다 업데이트를 함 → 실시간거도 된다

자주쓰는거만 new를 올림
